# Week 2 - Searching for Solutions

1. Motivation: Introducing search algorithms and how to improve their efficiency by minimizing a cost function.  Solving a problem involves moving from an initial state to the goal.  The domain of a problem, say the board game checkers, controls the number of possible states, and the actions that can be taken.  Imagine playing checkers without knowing any of the rules -- this is uninformed search -- and yes, winnig would take a long time.  Informed search -- where we know the rule and can evaluate the cost of each -- is a much more efficient way of finding the goal.  This week we will examine both types of algorithms, understand thier costs, and learn how to measure their performance.  

1. Learning objectives

    1. Contrast informed and uninformed search algorithms in terms of completness, optimality, time complexity and space complexity.

    1. Illustrate how a path through the state space from the initial state to the goal state is a product of actions taken to transistion from one state to the next.
    
    1. Explain and demonstrate breadth-first search, depth-first search, greedy best-first search and A* search algorithms.   

    1. Develop a working code that implement two different search algorithms.  

1. Readings
    1.  Read Chapter 3 - Solving Problems by Searching (all - except for 3.5.3, 3.6.2-4)

    1.  Text: Stuart Russel and Peter Norvig. _Artificial Intelligence: A Modern Approach_ (3rd ed). Prentice-Hall. 2010.

1. From the experts

    1.  TODO

1. Discussion

    1. Programming Assignment.    
